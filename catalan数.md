## `Catalan`数

- NLP-机器学习笔试面试题解析 [Github链接](https://github.com/WerterHong/Machine-Learning-Algorithm-NLP/)
- **`Catalan`数** (若公式显示错误，请点击此链接) [有道云笔记](http://note.youdao.com/noteshare?id=5c6ae60b514050b24e55ed6806078f30&sub=B03126AC31654928A3BD20A310872FAA)

### 1. `catalan`数

令`h(0)=1, h(1)=1, catalan`数满足递归式：

```math
h(n)=h(0)*h(n-1)+h(1)*h(n-2)+ \cdots +h(n-1)*h(0), \quad n \geq 2
```
也即

```math
h(n)=h(n-1)*(4*n-2)/(n+1)
```
递推关系的解为

```math
h(n)=C^n_{2n}/(n+1), \quad n=1,2,3,...
```
> `catalan`数前几项为：`1, 1, 2, 5, 14, 42, 132, ...`。

### 2. 应用场景

#### 2.1. 括号匹配

问题描述：`n`对括号有多少种匹配方式？

思路：`n`对括号相当于有`2n`个符号，`n`个左括号、`n`个右括号，可以设问题的解为`f(2n)`。第`0`个符号肯定为左括号，与之匹配的右括号必须为第`2i+1`字符。`f(2n)`递推式:

```math
f(2n) = f(0)*f(2n-2) + f(2)*f(2n - 4) + ... + f(2n - 4)*f(2) + f(2n-2)*f(0)
```
> 当`n=3`时，共有`6`个括号
> - 第`1`项（第`0`个左括号与第`1`个右括号匹配）：`()|()()` 、 `()|(())`
> - 第`2`项（第`0`个左括号与第`3`个右括号匹配）：`(())|()`
> - 第`3`项（第`0`个左括号与第`5`个右括号匹配）：`(()())|` 、 `((()))|`

> `n`对括号匹配：`f(2) = 1, f(4) = 2, f(6) = 5, f(8) = 14, ..., f(2n) = h(n)`

#### 2.2. 矩阵链乘

问题描述：`$P=a_1×a_2×a_3×...×a_n$`，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？

通过括号化，将`P`分成两个部分，然后分别对两个部分进行括号化。以此类推：

```math
f(n) = f(1)*f(n-1) + f(2)*f(n-2) + f(3)*f(n-3) + \cdots + f(n-1)*f(1)
```
> - 分成`$(a_1)×(a_2×a_3×...×a_n)$`：`$(a_1) | (a_2×a_3×...×a_n)$`
> - 分成`$(a_1×a_2)×(a_3×...×a_n)$`：`$(a_1×a_2) | (a_3×...×a_n)$`
> - `...`
> - 分成`$(a_1×a_2×a_3×...×a_{n-1})×a_n)$`：`$(a_1×a_2×a_3×...×a_{n-1}) | (a_n)$`

> `n`项矩阵链乘：`f(1) = 1, f(2) = 1, f(3) = 2, f(4) = 5, ... , f(n) = h(n-1)`

#### 2.3. 栈的出栈序列数

问题描述：一个栈(无穷大)的进栈序列为`1, 2, 3, ..., n`，有多少个不同的出栈序列?

思路：进栈操作相当于是左括号，而出栈操作相当于右括号。`n`个数的进栈次序和出栈次序构成了一个含`2n`个数字的序列。设问题的解为`f(2n)`，递推式:

```math
f(2n) = f(0)*f(2n-2) + f(2)*f(2n - 4) + ... + f(2n - 4)*f(2) + f(2n-2)*f(0)
```

> `n`个出栈序列数：`f(0) = 1, f(2) = 1, f(4) = 2, f(6) = 5, ..., f(2n) = h(n)`

**栗子一：** `n*n`的方格地图中，从一个角到另外一个角，不跨越对角线的路径数，例如， `4×4`方格地图中的路径有`f(2*4) = h(4) = 14`：

<p align="center">
    <img src="https://note.youdao.com/yws/public/resource/7dfe537f8298cea2d3a1d64dbcddb10d/E849937A56064F82ADA471ABA7C11665?ynotemdtimestamp=1566806757550" />
    <br />
    <strong>Fig</strong>. 4×4方格地图
</p>

**栗子二：** 有`2n`个人排成一行进入剧场。入场费`5`元。其中只有`n`个人有一张`5`元钞票，另外`n`人只有`10`元钞票，剧院无其它钞票，问有多少中方法使得只要有`10`元的人买票，售票处就有`5`元的钞票找零？

思路：可以将持`5`元买票视为进栈，那么持`10`元买票视为`5`元的出栈。这个问题就转化成了栈的出栈次序数。由分析直接得到结果，`f(2n) = h(n)`。

#### 2.4. 多边行划分为三角形

问题描述：求一个凸多边形区域划分成三角形区域的方法数？

思路：以凸多边形的一边为基，设这条边的`2`个顶点为`A`和`B`。从剩余顶点中选`1`个，可以将凸多边形分成三个部分，中间是一个三角形，左右两边分别是两个凸多边形，然后求解左右两个凸多边形。

```math
f(n) = f(2)*f(n-1) + f(3)*f(n-2) + ......f(n-2)*f(3) + f(n-1)*f(2)
```

<p align="center">
    <img src="https://note.youdao.com/yws/public/resource/7dfe537f8298cea2d3a1d64dbcddb10d/98D614C7A5ED4D3495B9EE1C751754D1?ynotemdtimestamp=1566806757550" />
    <br />
    <strong>Fig</strong>. n = 6 时，14 种划分
</p>

> 凸`n`边形划分三角形：`f(2) = 1, f(3) = 1, f(4) = 2, f(5) = 5, ..., f(n) = h(n-2)`

#### 2.5. 二叉树生成

问题描述：`n`个节顶点构成的二叉树，共有多少种情形？

思路：根肯定会占用一个结点，那么剩余的`n-1`个结点可以有如下的分配方式，`T(0, n-1),T(1, n-2),...T(n-1,0)`，设`T(i,j)`表示根的左子树含`i`个结点，右子树含`j`个结点。设问题的解为`f(n)`，递推式：
```math
f(n) = f(0)*f(n-1) + f(1)*f(n-2) + .......+ f(n-2)*f(1) + f(n-1)*f(0)
```

<p align="center">
    <img src="https://note.youdao.com/yws/public/resource/7dfe537f8298cea2d3a1d64dbcddb10d/CD1E9CBE1AE5457EA8E76D8AA095E8F9?ynotemdtimestamp=1566806757550" />
    <br />
    <strong>Fig</strong>. n = 3 时二叉树
</p>

> `n`个顶点构成二叉树：`f(0) = 1, f(1) = 1, f(2) = 2, f(3) = 5, ..., f(n) = h(n)`

#### 2.6. 不相交线段

问题描述：在圆上选择`2n`个点，将这些点成对连接起来使得所得到的`n`条线段不相交的方法数？

思路：以其中一个点为基点，编号为`0`，然后按顺时针方向将其他点依次编号。那么与编号为0相连点的编号一定是奇数。设问题的解`f(n)`，递推式：

```math
f(n) = f(0)*f(n-2) + f(2)*f(n-4) + f(4)*f(n-6) + ......f(n-4)*f(2) + f(n-2)*f(0)
```

<p align="center">
    <img src="https://note.youdao.com/yws/public/resource/7dfe537f8298cea2d3a1d64dbcddb10d/5793232880144BAF800AC78CA75B4029?ynotemdtimestamp=1566806757550" height=250 />
    <br />
    <strong>Fig</strong>. n = 3 时不相交线段
</p>

>  圆上`2n`个点连接成不相交线段：`f(0) = 1, f(2) = 1, f(4) = 2, ..., f(2n) = h(n)`

#### 2.7. 

#### 4. 

### 3. 参考代码

```
//python
//函数功能: 计算Catalan的第n项
def catalan(n):
    if n == 0 or n == 1:
        return 1
    return int((4*n-2)*catalan(n-1)/(n+1))
```


```
//C++
//函数功能: 计算Catalan的第n项
int Catalan(int n)
{
	if(n <= 1)
		return 1;
 
	int *h = new int [n+1];
	h[0] = h[1] = 1;
	for(int i = 2; i <= n; i++)
	{
		h[i] = 0;
		for(int j = 0; j < i; j++)
			h[i] += (h[j] * h[i-1-j]);
	}
	int result = h[n];
	delete [] h;
	return result;
}
```
